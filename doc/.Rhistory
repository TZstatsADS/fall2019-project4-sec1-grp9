View(RMSEOut)
system.time(
result <- foreach (movie = 1:ncol(bibin),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(bibin)[movie]
allInts <- sort(unique(train1 %>% filter(movieId==i) %>% pull(Interval_i))) #all intervals where this movie was rated
for (tInt in allInts){ #only need to update entry bibin(t,i) if t is within allInts
Ij <- train1 %>% filter(movieId==i,Interval_i == tInt) %>% arrange(userId)
RVec <- Ij$rating #all ratings of this movie, at this t
bis <- bi[as.character(Ij$movieId)]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie at this interval
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
bibin[tInt,i] <- (sum(RVec) - sum(bis) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
bibin[,i]
})
153.50/60
detectCores()
colnames(result) <- colnames(bibin)
bibin <- result
View(bibin)
RMSEOut$Train.bibin.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bibin.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
bu
movie
user
length(bu
)
user = 1
i <- names(bu)[user]
i
names(bu)
i <- names(bu)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
View(Ij)
as.character(Ij$movieId)
bi[as.character(Ij$movieId)]
head(Ij)
View(Ij)
bi[as.character(Ij$movieId)]
Ij$Interval_i
as.character(Ij$movieId)
match(as.character(Ij$movieId),colnames(bibins))
match(as.character(Ij$movieId),colnames(bibin))
atch(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin)
match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin)
Ij$Interval_i
match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)
match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
bibins
head(Ij)
bibins[5,'3']
bibin[5,'3']
bibin[1]
bibins[1]
bibin[5,'6']
bibins[2]
bibin[5,'101']
bibins[6]
bibins
alphau[as.character(Ij$userId)]
as.character(Ij$userId)
alphau[as.character(Ij$userId)]
Ij$Dev
alphau[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
alphauDevs
Ij$movieId
as.character(Ij$movieId[k])
k= 1
as.character(Ij$movieId[k])
q[,as.character(Ij$movieId[k])]
p[,as.character(Ij$userId[k])]
Ij$userId
Ij$Dev[k]
alphap[,as.character(Ij$userId[k])]
sum(bis)
bis
bi[as.character(Ij$movieId)]
bis <- bi[as.character(Ij$movieId)]
bis
RVec
RVec <- Ij$rating #all ratings from this user
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))
(nrow(Ij)+lambda)
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(0)
maxIter <- 10
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())
#the model is r_ui(t) = mu + b_i(t) +  b_u(t) + q^T %*% p(t), where
#b_i(t) = b_i + b_(i,Bin(t))
#b_u(t) = b_u + alpha_u * dev_u(t)
#p_u(t) = p_u + alpha_p * dev_u(t)
#For further details see P5.
f = 10
lambda = 0.1
max.iter = 10
train = data_train
test=data_test
data$Date <-as.Date(as.POSIXlt(data$timestamp,origin = "1970-01-01",tz = 'UTC'))
train$Date <- as.Date(as.POSIXlt(train$timestamp,origin = "1970-01-01",tz = 'UTC'))
test$Date <- as.Date(as.POSIXlt(test$timestamp,origin = "1970-01-01",tz = 'UTC'))
dateIntervals <- as.Date(paste0(sort(unique(as.numeric(format(data$Date,'%Y')))),'-01-01')) #use years as Date Bins for b_i(t)
train$Interval_i <- findInterval(train$Date,dateIntervals)
test$Interval_i <- findInterval(test$Date,dateIntervals)
tu <- as.data.frame(data %>% group_by(userId) %>% summarise(MeanDate = round_date(mean(Date),'day'))) #mean date of rating for each user
#here we precompute dev_u(t) for each entry. This is computed as (signed) (devation from the mean date of rating ^0.4). 0.4 is the paramter Beta taken from P5
train$Dev <- as.numeric(sign(train$Date- tu$MeanDate[match(train$userId,tu$userId)]) *(as.numeric(abs((train$Date- tu$MeanDate[match(train$userId,tu$userId)])))^0.4))
test$Dev <- as.numeric(sign(test$Date- tu$MeanDate[match(test$userId,tu$userId)]) *(as.numeric(abs((test$Date- tu$MeanDate[match(test$userId,tu$userId)])))^0.4))
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
#################initialize paramters################
#mu,mean of all movie ratings
mu <- mean(train$rating)
#b_i.Non time-based biase for each movie, initialized to be 0
bi <- rep(0,I); names(bi) <- levels(as.factor(data$movieId))
#bibin(t), time-based biase for each movie, initialized to be 0
bibin <- matrix(0,length(dateIntervals),I); colnames(bibin) <- levels(as.factor(data$movieId))
#b_u. Non time-based biase for each user, initialized to be 0
bu <-  rep(0,U); names(bu) <- levels(as.factor(data$userId))
#alpha_u. The coefficient for dev_u(t), initialized to be 0
alphau <- rep(0,U); names(alphau) <- levels(as.factor(data$userId))
#p = user matrix; q = movie matrix
#assign random small value to matrix p and q
p <- matrix(runif(f*U, -1, 1), ncol = U)
colnames(p) <- levels(as.factor(data$userId))
##alpha parametr associated with p(t), initialized to be 0
alphap <- matrix(0,nrow = f, ncol = U)
colnames(alphap) <- levels(as.factor(data$userId))
q <- matrix(runif(f*I, -1, 1), ncol = I)
colnames(q) <- levels(as.factor(data$movieId))
########################################################
#RMSE at Start
RMSEOut <- data.frame(matrix(NA,max.iter+1,15))
colnames(RMSEOut) <- c("Iteration",'Train.bi.Update','Train.bibin.Update','Train.bu.Update','Train.alphau.Update','Train.P.Update','Train.alphap.Update','Train.Q.Update',
'Test.bi.Update','Test.bibin.Update','Test.bu.Update','Test.alphau.Update','Test.P.Update','Test.alphap.Update','Test.Q.Update')
RMSEOut$Iteration <- c(0:max.iter)
RMSEOut$Train.Q.Update[1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.Q.Update[1] <- RMSE2(test, predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE at start, training:", RMSEOut$Train.Q.Update[1], "\t testing:",RMSEOut$Test.Q.Update[1], "\n")
#demean the training data for efficiency
train1 <- train; train1$rating <- train1$rating - mu
l=1
#update bi. Runtime on 8 core parallel is 30 seconds
result <- foreach (movie = 1:length(bi),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bi)[movie]
Ij <- train1 %>% filter(movieId==i) %>% arrange(userId) #all data related to this movie
RVec <- Ij$rating #all ratings of this movie
bibins <-  bibin[Ij$Interval_i,i]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bibins) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bi)
bi <- result
RMSEOut$Train.bi.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bi.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
#update bibin. Runtime on 8 core parallel is 3 minutes
result <- foreach (movie = 1:ncol(bibin),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(bibin)[movie]
allInts <- sort(unique(train1 %>% filter(movieId==i) %>% pull(Interval_i))) #all intervals where this movie was rated
for (tInt in allInts){ #only need to update entry bibin(t,i) if t is within allInts
Ij <- train1 %>% filter(movieId==i,Interval_i == tInt) %>% arrange(userId)
RVec <- Ij$rating #all ratings of this movie, at this t
bis <- bi[as.character(Ij$movieId)]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie at this interval
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
bibin[tInt,i] <- (sum(RVec) - sum(bis) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
bibin[,i]
}
colnames(result) <- colnames(bibin)
bibin <- result
RMSEOut$Train.bibin.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bibin.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
View(RMSEOut)
View(RMSEOut)
system.time(
result <- foreach (user = 1:length(bu),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bu)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
RVec <- Ij$rating #all ratings from this user
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
})
result
names(result) <- names(bu)
bu <- result
bu
RMSEOut$Train.bu.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bu.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
View(RMSEOut)
alphau
user
user = 1
i <- names(alphau)[user]
i
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
View(Ij)
Ij$rating
View(Ij)
Ij$Dev
Ij$rating * Ij$Dev
bi[as.character(Ij$movieId)]
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
as.character(Ij$userId)
bu[as.character(Ij$userId)]
* Ij$Dev
Ij$Dev
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
RVec
bis
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec
View(Ij)
PRVec <- PRVec * Ij$Dev
PRVec
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))
sum(bus)
bu[as.character(Ij$userId)]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
sum(bus)
bi[as.character(Ij$movieId)]
sum(bis)
(sum(RVec)
sum(RVec)
sum(RVec)
sum(bis)
sum(bibins)
sum(bus
)
sum(RVec) - sum(bis) - sum(bibins) - sum(bus)
sum(PRVec)
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))
(nrow(Ij)
(nrow(Ij)+lambda)
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(nrow(Ij)+lambda)
sum(Ij$Dev)
(Ij$Dev  )^2
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(nrow(Ij)+lambda)
Ij$Dev^2
sum(Ij$Dev^2)
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(nrow(Ij)+lambda)
alphau
system.time(
result <- foreach (user = 1:length(alphau),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(alphau)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
#everything here is multiplied by Dev
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec <- PRVec * Ij$Dev
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
})
alphau
head(alphau)
head(result)
names(result) <- names(alphau.)
alphau. <- result
alphau <- result
head(alphau)
RMSEOut$Train.alphau.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.alphau.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
View(RMSEOut)
View(RMSEOut)
RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(0)
maxIter <- 10
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())
#the model is r_ui(t) = mu + b_i(t) +  b_u(t) + q^T %*% p(t), where
#b_i(t) = b_i + b_(i,Bin(t))
#b_u(t) = b_u + alpha_u * dev_u(t)
#p_u(t) = p_u + alpha_p * dev_u(t)
#For further details see P5.
f = 10
lambda = 0.1
max.iter = 10
train = data_train
test=data_test
data$Date <-as.Date(as.POSIXlt(data$timestamp,origin = "1970-01-01",tz = 'UTC'))
train$Date <- as.Date(as.POSIXlt(train$timestamp,origin = "1970-01-01",tz = 'UTC'))
test$Date <- as.Date(as.POSIXlt(test$timestamp,origin = "1970-01-01",tz = 'UTC'))
dateIntervals <- as.Date(paste0(sort(unique(as.numeric(format(data$Date,'%Y')))),'-01-01')) #use years as Date Bins for b_i(t)
train$Interval_i <- findInterval(train$Date,dateIntervals)
test$Interval_i <- findInterval(test$Date,dateIntervals)
tu <- as.data.frame(data %>% group_by(userId) %>% summarise(MeanDate = round_date(mean(Date),'day'))) #mean date of rating for each user
#here we precompute dev_u(t) for each entry. This is computed as (signed) (devation from the mean date of rating ^0.4). 0.4 is the paramter Beta taken from P5
train$Dev <- as.numeric(sign(train$Date- tu$MeanDate[match(train$userId,tu$userId)]) *(as.numeric(abs((train$Date- tu$MeanDate[match(train$userId,tu$userId)])))^0.4))
test$Dev <- as.numeric(sign(test$Date- tu$MeanDate[match(test$userId,tu$userId)]) *(as.numeric(abs((test$Date- tu$MeanDate[match(test$userId,tu$userId)])))^0.4))
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
#################initialize paramters################
#mu,mean of all movie ratings
mu <- mean(train$rating)
#b_i.Non time-based biase for each movie, initialized to be 0
bi <- rep(0,I); names(bi) <- levels(as.factor(data$movieId))
#bibin(t), time-based biase for each movie, initialized to be 0
bibin <- matrix(0,length(dateIntervals),I); colnames(bibin) <- levels(as.factor(data$movieId))
#b_u. Non time-based biase for each user, initialized to be 0
bu <-  rep(0,U); names(bu) <- levels(as.factor(data$userId))
#alpha_u. The coefficient for dev_u(t), initialized to be 0
alphau <- rep(0,U); names(alphau) <- levels(as.factor(data$userId))
#p = user matrix; q = movie matrix
#assign random small value to matrix p and q
p <- matrix(runif(f*U, -1, 1), ncol = U)
colnames(p) <- levels(as.factor(data$userId))
##alpha parametr associated with p(t), initialized to be 0
alphap <- matrix(0,nrow = f, ncol = U)
colnames(alphap) <- levels(as.factor(data$userId))
q <- matrix(runif(f*I, -1, 1), ncol = I)
colnames(q) <- levels(as.factor(data$movieId))
########################################################
#RMSE at Start
RMSEOut <- data.frame(matrix(NA,max.iter+1,15))
colnames(RMSEOut) <- c("Iteration",'Train.bi.Update','Train.bibin.Update','Train.bu.Update','Train.alphau.Update','Train.P.Update','Train.alphap.Update','Train.Q.Update',
'Test.bi.Update','Test.bibin.Update','Test.bu.Update','Test.alphau.Update','Test.P.Update','Test.alphap.Update','Test.Q.Update')
RMSEOut$Iteration <- c(0:max.iter)
RMSEOut$Train.Q.Update[1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.Q.Update[1] <- RMSE2(test, predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE at start, training:", RMSEOut$Train.Q.Update[1], "\t testing:",RMSEOut$Test.Q.Update[1], "\n")
#demean the training data for efficiency
train1 <- train; train1$rating <- train1$rating - mu
l=1
cat("Iteration =",l,':\n')
#update bi. Runtime on 8 core parallel is 30 seconds
result <- foreach (movie = 1:length(bi),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bi)[movie]
Ij <- train1 %>% filter(movieId==i) %>% arrange(userId) #all data related to this movie
RVec <- Ij$rating #all ratings of this movie
bibins <-  bibin[Ij$Interval_i,i]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bibins) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bi)
bi <- result
RMSEOut$Train.bi.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bi.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
#update bibin. Runtime on 8 core parallel is 3 minutes
result <- foreach (movie = 1:ncol(bibin),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(bibin)[movie]
allInts <- sort(unique(train1 %>% filter(movieId==i) %>% pull(Interval_i))) #all intervals where this movie was rated
for (tInt in allInts){ #only need to update entry bibin(t,i) if t is within allInts
Ij <- train1 %>% filter(movieId==i,Interval_i == tInt) %>% arrange(userId)
RVec <- Ij$rating #all ratings of this movie, at this t
bis <- bi[as.character(Ij$movieId)]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie at this interval
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
bibin[tInt,i] <- (sum(RVec) - sum(bis) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
bibin[,i]
}
colnames(result) <- colnames(bibin)
bibin <- result
RMSEOut$Train.bibin.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bibin.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
#update bu. Runtime on 8 core parallel is 2.39 seconds
result <- foreach (user = 1:length(bu),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bu)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
RVec <- Ij$rating #all ratings from this user
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bu)
bu <- result
RMSEOut$Train.bu.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bu.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
View(RMSEOut)
View(RMSEOut)
#update alphau. Runtime on 8 core parallel is 1.72 seconds
result <- foreach (user = 1:length(alphau),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(alphau)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
#everything here is multiplied by Dev
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec <- PRVec * Ij$Dev
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
}
names(result) <- names(alphau)
alphau <- result
RMSEOut$Train.alphau.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.alphau.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
View(RMSEOut)
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(0)
maxIter <- 10
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())
out <- als.t(f = 10,  lambda = 0.1,max.iter = 1,data = data, train = data_train, test = data_test)
out
out$RMSE
a <- out$RMSE
View(a)
