bibins <- bibin[bibinInds]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
MIt <- MI + (alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij)))
# V <- MI %*% RVec - MI %*% bis - MI %*% bibins - MI %*% bus - MI %*% alphauDevs - MI %*% t(MI) %*% alphapDevs
V <- MIt %*% (RVec - bis - bibins -  bus -  alphauDevs)
A <-  MIt %*% t(MIt) + lambda * nrow(Ij) * diag(f)
solve(A,tol = 1e-30) %*% V
}
colnames(result) <- colnames(q)
q <- result
RMSEOut$Train.Q.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.Q.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating q, training:", RMSEOut$Train.Q.Update[l+1], "\t testing:",RMSEOut$Test.Q.Update[l+1], "\n")
a <- result[,which(apply(result,2,FUN = function(x){
any(abs(x) >=10)
}))]
a <- result[,which(apply(result,2,FUN = function(x){
any(abs(x) >=10)
}))]
View(result)
which(apply(result,2,FUN = function(x){
any(abs(x) >=10)
}))
l=2
cat("Iteration =",l,':\n')
#update bi. Runtime on 8 core parallel is 30 seconds
result <- foreach (movie = 1:length(bi),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bi)[movie]
Ij <- train1 %>% filter(movieId==i) %>% arrange(userId) #all data related to this movie
RVec <- Ij$rating #all ratings of this movie
bibins <-  bibin[Ij$Interval_i,i]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bibins) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bi)
bi <- result
RMSEOut$Train.bi.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bi.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bi, training:", RMSEOut$Train.bi.Update[l+1], "\t testing:",RMSEOut$Test.bi.Update[l+1], "\n")
#update bibin. Runtime on 8 core parallel is 3 minutes
result <- foreach (movie = 1:ncol(bibin),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(bibin)[movie]
allInts <- sort(unique(train1 %>% filter(movieId==i) %>% pull(Interval_i))) #all intervals where this movie was rated
for (tInt in allInts){ #only need to update entry bibin(t,i) if t is within allInts
Ij <- train1 %>% filter(movieId==i,Interval_i == tInt) %>% arrange(userId)
RVec <- Ij$rating #all ratings of this movie, at this t
bis <- bi[as.character(Ij$movieId)]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie at this interval
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
bibin[tInt,i] <- (sum(RVec) - sum(bis) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
bibin[,i]
}
colnames(result) <- colnames(bibin)
bibin <- result
RMSEOut$Train.bibin.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bibin.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bibin, training:", RMSEOut$Train.bibin.Update[l+1], "\t testing:",RMSEOut$Test.bibin.Update[l+1], "\n")
#update bu. Runtime on 8 core parallel is 2.39 seconds
result <- foreach (user = 1:length(bu),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bu)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
RVec <- Ij$rating #all ratings from this user
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bu)
bu <- result
RMSEOut$Train.bu.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bu.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bu, training:", RMSEOut$Train.bu.Update[l+1], "\t testing:",RMSEOut$Test.bu.Update[l+1], "\n")
#update alphau. Runtime on 8 core parallel is 1.72 seconds
result <- foreach (user = 1:length(alphau),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(alphau)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
#everything here is multiplied by Dev
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec <- PRVec * Ij$Dev
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
}
names(result) <- names(alphau)
alphau <- result
RMSEOut$Train.alphau.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.alphau.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating alphau, training:", RMSEOut$Train.alphau.Update[l+1], "\t testing:",RMSEOut$Test.alphau.Update[l+1], "\n")
#update p. Runtime on 8 core parallel is 1.13 seconds
result <- foreach (user = 1:ncol(p),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(p)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
MI <- q[,as.character(Ij$movieId)]
RVec <- Ij$rating
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
alphapDevs <- alphap[,as.character(Ij$userId)] %*% Ij$Dev
# V <- MI %*% RVec - MI %*% bis - MI %*% bibins - MI %*% bus - MI %*% alphauDevs - MI %*% t(MI) %*% alphapDevs
V <- MI %*% (RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
A <-  MI %*% t(MI) + lambda * nrow(Ij) * diag(f)
solve(A,tol = 1e-30) %*% V
}
colnames(result) <- colnames(p)
p <- result
RMSEOut$Train.P.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.P.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating p, training:", RMSEOut$Train.P.Update[l+1], "\t testing:",RMSEOut$Test.P.Update[l+1], "\n")
a <- result[,which(apply(alphap,2,FUN = function(x){
any(abs(x) >=10)
}))]
a <- result[,which(apply(q,2,FUN = function(x){
any(abs(x) >=10)
}))]
a <- q[,which(apply(q,2,FUN = function(x){
any(abs(x) >=10)
}))]
which(apply(q,2,FUN = function(x){
any(abs(x) >=10)
}))
alphap[,which(apply(alphap,2,FUN = function(x){
any(abs(x) >=10)
}))]
which(apply(alphap,2,FUN = function(x){
any(abs(x) >=10)
}))
colnames(alphap)
colnames(q)
q[,which(apply(q,2,FUN = function(x){
any(abs(x) >=10)
}))]
p[,which(apply(p,2,FUN = function(x){
any(abs(x) >=10)
}))]
a <- p[,which(apply(p,2,FUN = function(x){
any(abs(x) >=10)
}))]
View(a)
a[,'13316']
a <- predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu)
a
max(a)
max(abs(a))
min(a)
which(a==max(a))
p[,'599']
q[,'4275']
alphap[,'599']
View(alphap)
max(alphap)
min(alphap)
mean(alphap)
i='599'
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
MI <- q[,as.character(Ij$movieId)]
RVec <- Ij$rating
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
alphapDevs <- alphap[,as.character(Ij$userId)] %*% Ij$Dev
# V <- MI %*% RVec - MI %*% bis - MI %*% bibins - MI %*% bus - MI %*% alphauDevs - MI %*% t(MI) %*% alphapDevs
V <- MI %*% (RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
A <-  MI %*% t(MI) + lambda * nrow(Ij) * diag(f)
solve(A,tol = 1e-30) %*% V
p[,'599']
MI %*% t(MI)
MI %*% (RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
MI
View(MI)
a <- MI[,which(apply(MI,2,FUN = function(x){
any(abs(x) >=10)
}))]
apply(MI,2,FUN = function(x){
any(abs(x) >=10)
}))
MI
View(Ij)
which(apply(MI,2,FUN = function(x){
any(abs(x) >=10)
}))
max(MI)
min(MI)
View(MI)
MI %*% t(MI)
MI %*% (RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
(RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
RVec
bis
bibins
bus
alphauDevs
alphapDevs
t(MI) %*% alphapDevs
alphapDevs
alphap[,as.character(Ij$userId)]
a <- alphap[,as.character(Ij$userId)]
View(a)
dim(alphap[,as.character(Ij$userId)])
t(MI) %*% alphapDevs
dim(t(MI) %*% alphapDevs)
a <-  alphap[,as.character(Ij$userId)]
dim(a)
a <- alphau[as.character(Ij$userId)]
dim(a)
max(alphap)
min(aalpha())
min(alphap)
?runif
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(123)
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())# use parallelization for faster procesing
out <- als.t(f = 10,  lambda = 0.01,max.iter = 3,data = data, train = data_train, test = data_test)
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(123)
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())# use parallelization for faster procesing
# out <- als.t(f = 10,  lambda = 0.01,max.iter = 3,data = data, train = data_train, test = data_test)
f = 10
lambda = 0.01
max.iter = 3
train = data_train
test = data_test
#some pre processing work: add Date, Interval, and Deviation to columns
data$Date <-as.Date(as.POSIXlt(data$timestamp,origin = "1970-01-01",tz = 'UTC'))
train$Date <- as.Date(as.POSIXlt(train$timestamp,origin = "1970-01-01",tz = 'UTC'))
test$Date <- as.Date(as.POSIXlt(test$timestamp,origin = "1970-01-01",tz = 'UTC'))
dateIntervals <- as.Date(paste0(sort(unique(as.numeric(format(data$Date,'%Y')))),'-01-01')) #use years as Date Bins for b_i(t)
train$Interval_i <- findInterval(train$Date,dateIntervals)
test$Interval_i <- findInterval(test$Date,dateIntervals)
tu <- as.data.frame(data %>% group_by(userId) %>% summarise(MeanDate = round_date(mean(Date),'day'))) #mean date of rating for each user
#here we precompute dev_u(t) for each entry. This is computed as (signed) (devation from the mean date of rating ^0.4). 0.4 is the paramter Beta taken from P5
train$Dev <- as.numeric(sign(train$Date- tu$MeanDate[match(train$userId,tu$userId)]) *(as.numeric(abs((train$Date- tu$MeanDate[match(train$userId,tu$userId)])))^0.4))
test$Dev <- as.numeric(sign(test$Date- tu$MeanDate[match(test$userId,tu$userId)]) *(as.numeric(abs((test$Date- tu$MeanDate[match(test$userId,tu$userId)])))^0.4))
U <- length(unique(data$userId))
I <- length(unique(data$movieId))
#################initialize paramters################
#mu,mean of all movie ratings
mu <- mean(train$rating)
#b_i.Non time-based biase for each movie, initialized to be 0
bi <- rep(0,I); names(bi) <- levels(as.factor(data$movieId))
#bibin(t), time-based biase for each movie, initialized to be 0
bibin <- matrix(0,length(dateIntervals),I); colnames(bibin) <- levels(as.factor(data$movieId))
#b_u. Non time-based biase for each user, initialized to be 0
bu <-  rep(0,U); names(bu) <- levels(as.factor(data$userId))
#alpha_u. The coefficient for dev_u(t), initialized to be 0
alphau <- rep(0,U); names(alphau) <- levels(as.factor(data$userId))
#p = user matrix; q = movie matrix
#assign random small value to matrix p and q
p <- matrix(runif(f*U, -1, 1), ncol = U)
colnames(p) <- levels(as.factor(data$userId))
##alpha parametr associated with p(t), initialized to be 0
# alphap <- matrix(0,nrow = f, ncol = U)
alphap <- matrix(runif(f*U,-0.1,0.1),nrow = f, ncol = U)
colnames(alphap) <- levels(as.factor(data$userId))
q <- matrix(runif(f*I, -1, 1), ncol = I)
colnames(q) <- levels(as.factor(data$movieId))
########################################################
#RMSE at Start
RMSEOut <- data.frame(matrix(NA,max.iter+1,15))
colnames(RMSEOut) <- c("Iteration",'Train.bi.Update','Train.bibin.Update','Train.bu.Update','Train.alphau.Update','Train.P.Update','Train.alphap.Update','Train.Q.Update',
'Test.bi.Update','Test.bibin.Update','Test.bu.Update','Test.alphau.Update','Test.P.Update','Test.alphap.Update','Test.Q.Update')
RMSEOut$Iteration <- c(0:max.iter)
RMSEOut$Train.Q.Update[1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.Q.Update[1] <- RMSE2(test, predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE at start, training:", RMSEOut$Train.Q.Update[1], "\t testing:",RMSEOut$Test.Q.Update[1], "\n")
#demean the training data for efficiency
train1 <- train; train1$rating <- train1$rating - mu
æŽ
l=1
cat("Iteration =",l,':\n')
#update bi. Runtime on 8 core parallel is 30 seconds
result <- foreach (movie = 1:length(bi),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bi)[movie]
Ij <- train1 %>% filter(movieId==i) %>% arrange(userId) #all data related to this movie
RVec <- Ij$rating #all ratings of this movie
bibins <-  bibin[Ij$Interval_i,i]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bibins) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bi)
bi <- result
RMSEOut$Train.bi.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bi.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bi, training:", RMSEOut$Train.bi.Update[l+1], "\t testing:",RMSEOut$Test.bi.Update[l+1], "\n")
#update bibin. Runtime on 8 core parallel is 3 minutes
result <- foreach (movie = 1:ncol(bibin),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(bibin)[movie]
allInts <- sort(unique(train1 %>% filter(movieId==i) %>% pull(Interval_i))) #all intervals where this movie was rated
for (tInt in allInts){ #only need to update entry bibin(t,i) if t is within allInts
Ij <- train1 %>% filter(movieId==i,Interval_i == tInt) %>% arrange(userId)
RVec <- Ij$rating #all ratings of this movie, at this t
bis <- bi[as.character(Ij$movieId)]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this movie at this interval
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,i]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
bibin[tInt,i] <- (sum(RVec) - sum(bis) - sum(bus) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
bibin[,i]
}
colnames(result) <- colnames(bibin)
bibin <- result
RMSEOut$Train.bibin.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bibin.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bibin, training:", RMSEOut$Train.bibin.Update[l+1], "\t testing:",RMSEOut$Test.bibin.Update[l+1], "\n")
#update bu. Runtime on 8 core parallel is 2.39 seconds
result <- foreach (user = 1:length(bu),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(bu)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
RVec <- Ij$rating #all ratings from this user
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
(sum(RVec) - sum(bis) - sum(bibins) - sum(alphauDevs) - sum(PRVec))/(nrow(Ij)+lambda)
}
names(result) <- names(bu)
bu <- result
RMSEOut$Train.bu.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.bu.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating bu, training:", RMSEOut$Train.bu.Update[l+1], "\t testing:",RMSEOut$Test.bu.Update[l+1], "\n")
#update alphau. Runtime on 8 core parallel is 1.72 seconds
result <- foreach (user = 1:length(alphau),.combine = c,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- names(alphau)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
#everything here is multiplied by Dev
RVec <- Ij$rating * Ij$Dev
bis <- bi[as.character(Ij$movieId)] * Ij$Dev
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]* Ij$Dev
bus <- bu[as.character(Ij$userId)]* Ij$Dev
PRVec <- c() #all factor-predicted ratings of this user
for (k in 1:nrow(Ij)){
PRVec[k] <- (t(q[,as.character(Ij$movieId[k])]) %*% (p[,as.character(Ij$userId[k])] + alphap[,as.character(Ij$userId[k])] *  Ij$Dev[k]))[1]
}
PRVec <- PRVec * Ij$Dev
(sum(RVec) - sum(bis) - sum(bibins) - sum(bus) - sum(PRVec))/(sum(Ij$Dev^2)+lambda)
}
names(result) <- names(alphau)
alphau <- result
RMSEOut$Train.alphau.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.alphau.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating alphau, training:", RMSEOut$Train.alphau.Update[l+1], "\t testing:",RMSEOut$Test.alphau.Update[l+1], "\n")
user = 1
i <- colnames(p)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
MI <- q[,as.character(Ij$movieId)]
RVec <- Ij$rating
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
View(Ij)
alphap[,as.character(Ij$userId)]
dim(alphapDevs)
alphapDevs <- alphap[,as.character(Ij$userId)] %*% Ij$Dev
a <- alphap[,as.character(Ij$userId)]
dim(a)
dim(MI)
as.character(Ij$userId)
alphap[,i] * Ij$Dev
alphap[,i]
Ij$Dev
alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij))
a <- alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij))
dim(a)
dim(MI)
t(MI) %*% a
b <-t(MI) %*% a
dim(b)
dim(b)
dim(a)
a %*% MI
b <- a %*% t(MI)
b
MI %*% t(MI)
MI %*% RVec
MI %*% t(MI)
alphap[,as.character(Ij$userId)] %*% Ij$Dev
alphap[,as.character(Ij$userId)]
a
View(a)
colSums(a)
rowSums(a)
alphapDevs
dim(MI)
colSums(a)
MI %*% colSums(a)
alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij))
colSums(alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij)))
alphapDevs <- colSums(alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij)))
MI %*% alphapDevs
MI %*% (RVec - bis - bibins -  bus -  alphauDevs -MI %*% alphapDevs)
alphauDevs
length(alphauDevs)
colSums(alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij)))
MI %*% alphapDevs
alphapDevs
alphapDevs
MI %*% (RVec - bis - bibins -  bus -  alphauDevs - alphapDevs)
MI %*% t(MI
MI %*% t(MI)
result <- foreach (user = 1:ncol(p),.combine = cbind,.packages = c('dplyr','tidyr','foreach')) %dopar%{
i <- colnames(p)[user]
Ij <- train1 %>% filter(userId==i) %>% arrange(movieId) #all data related to this user
MI <- q[,as.character(Ij$movieId)]
RVec <- Ij$rating
bis <- bi[as.character(Ij$movieId)]
bibinInds <- match(as.character(Ij$movieId),colnames(bibin)) * nrow(bibin) - (nrow(bibin)-Ij$Interval_i)#retrive relevant bibin elements
bibins <- bibin[bibinInds]
bus <- bu[as.character(Ij$userId)]
alphauDevs <- alphau[as.character(Ij$userId)] * Ij$Dev
# alphapDevs <- alphap[,as.character(Ij$userId)] %*% Ij$Dev
alphapDevs <- colSums(alphap[,as.character(Ij$userId)] %*% diag(Ij$Dev,nrow = nrow(Ij)))
# V <- MI %*% RVec - MI %*% bis - MI %*% bibins - MI %*% bus - MI %*% alphauDevs - MI %*% t(MI) %*% alphapDevs
# V <- MI %*% (RVec - bis - bibins -  bus -  alphauDevs -t(MI) %*% alphapDevs)
V <- MI %*% (RVec - bis - bibins -  bus -  alphauDevs - alphapDevs)
A <-  MI %*% t(MI) + lambda * nrow(Ij) * diag(f)
solve(A,tol = 1e-30) %*% V
}
colnames(result) <- colnames(p)
p <- result
RMSEOut$Train.P.Update[l+1] <- RMSE2(train,predictRating(train,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
RMSEOut$Test.P.Update[l+1] <- RMSE2(test,predictRating(test,mu,q,p,bi,bibin,bu,alphau,alphap,dateIntervals,tu))
cat("RMSE after updating p, training:", RMSEOut$Train.P.Update[l+1], "\t testing:",RMSEOut$Test.P.Update[l+1], "\n")
View(RMSEOut)
setwd('D:/wwyws/Documents/Columbia/STAT5243 Applied Data Science/fall2019-project4-sec1-grp9/doc')
### Step 1 Load Data and Train-test Split
library(dplyr)
library(tidyr)
library(ggplot2)
library(foreach)
library(doParallel)
library(zoo)
library(Matrix)
library(lubridate)
source("../lib/Matrix_Factorization.R")
source("../lib/cross_validation.R")
data <- read.csv("../data/ml-latest-small/ratings.csv")
set.seed(123)
dataSplit <- train_test_split(data,0.8) #this function ensures that all users and movies are in the training set.
data_train <- dataSplit$train
data_test <- dataSplit$test
registerDoParallel(cores = detectCores())# use parallelization for faster procesing
out <- als.t(f = 10,  lambda = 0.01,max.iter = 3,data = data, train = data_train, test = data_test)
